# CodeRabbit Configuration for Flutter AI Agent SDK
# MAXIMUM STRICTNESS - ABSOLUTELY NO COMPROMISES
# ZERO-TOLERANCE POLICY - EVERY SINGLE ISSUE MUST BE FIXED
# PRODUCTION-GRADE CODE QUALITY ENFORCEMENT

# Language Configuration - FIXED: Use locale code, not programming language
language: en-US

# Review Settings
reviews:
  # MAXIMUM STRICT review profile - MOST AGGRESSIVE
  profile: assertive
  
  # ALWAYS ALWAYS ALWAYS request changes on ANY issues - NO EXCEPTIONS
  request_changes_workflow: true
  
  # Enable ALL review categories with MAXIMUM POSSIBLE scrutiny
  auto_review:
    enabled: true
    drafts: true
    ignore_title_keywords: []
    labels: []
    base_branches: []
  
  # High effort mode for maximum thoroughness
  high_level_summary: true
  poem: false
  review_status: true
  collapse_walkthrough: false
  
  # Enable all review tools
  tools:
    github-checks: true
    similarity-analysis: true
    
  # Maximum number of files and lines to review (no limits)
  limits:
    max_files: 1000
    max_lines_per_review: 10000

# Path-based Configuration
path_instructions:
  - path: "lib/**/*.dart"
    instructions: |
      CRITICAL REQUIREMENTS (ZERO TOLERANCE):
      - Enforce strict null safety - NO nullable types without explicit handling
      - ALL public APIs MUST have comprehensive documentation with examples
      - ALL functions MUST have explicit return type annotations
      - ALL parameters MUST have explicit type annotations
      - Verify error handling is comprehensive with try-catch blocks
      - Check for proper resource disposal (dispose methods, close streams, cancel subscriptions)
      - Ensure immutability where appropriate (prefer final, const)
      - Verify NO business logic in constructors
      - Check for memory leaks (unclosed streams, listeners, controllers)
      - Ensure ALL async operations are properly awaited or explicitly ignored
      - Verify thread safety for concurrent operations
      - NO print statements - use proper logging
      - NO TODO/FIXME comments allowed
      - NO magic numbers - use named constants
      - NO hardcoded strings - use constants or localization
      - ALL classes must follow single responsibility principle
      - ALL methods must be under 30 lines (MAXIMUM)
      - Cyclomatic complexity must be under 10 (STRICT)
      - Cognitive complexity must be under 15
      - Nesting depth NEVER exceed 3 levels
      - NO dynamic types unless absolutely necessary with justification
      - ALL exceptions must be caught and handled appropriately
      - NO empty catch blocks
      - ALL widget keys must be provided for testability
      - BuildContext must NEVER be used after async gaps
      - ALL streams must be closed in dispose
      - ALL controllers must be disposed
      - Prefer composition over inheritance
      - Use dependency injection for all dependencies
      - NO global state or singletons without justification
      - EVERY class must have a single, well-defined purpose
      - EVERY method must do ONE thing only
      - NO nested ternary operators
      - NO multiple return statements (except guard clauses)
      - ALL boolean parameters must be named parameters
      - NO abbreviations in names (except standard ones like id, url, http)
      - ALL error messages must be descriptive and actionable
      - NO string concatenation - use string interpolation or StringBuffer
      - ALL collections must use const where possible
      - NO mutable global variables
      - ALL DateTime must be in UTC
      - NO floating point comparisons without epsilon
      - ALL file I/O must be async
      - NO blocking operations on main thread
      - ALL network calls must have timeout
      - ALL caches must have size limits
      - NO reflection unless absolutely necessary
      - ALL platform channels must have error handling
      - NO direct widget tree manipulation
      - ALL animations must be disposed
      - NO setState during build
      - ALL InheritedWidgets must be immutable
      - NO BuildContext usage across async boundaries
      - ALL StatefulWidgets must dispose resources
      - NO widget rebuilds without reason
      - ALL keys must be const where possible
      - NO anonymous functions in build methods (extract to methods)
      - ALL Hero tags must be unique
      - NO Navigator.pop without checking canPop
      - ALL TextEditingControllers must be disposed
      - NO FocusNodes without disposal
      - ALL ScrollControllers must be disposed
      - NO AnimationControllers without disposal
      - ALL Streams must be single-subscription or broadcast explicitly
      - NO StreamController without close
      - ALL Completer must be completed
      - NO Future without error handling
      - ALL isolates must be killed
      - NO compute without error handling
      
      ADDITIONAL ULTRA-STRICT REQUIREMENTS:
      - ALL public classes must have @immutable or @sealed annotations where appropriate
      - NO var keyword - use explicit types or final/const
      - ALL List/Map/Set declarations must specify generic types
      - NO nullable types in constructors without default values
      - ALL factory constructors must have comprehensive documentation
      - NO static mutable state
      - ALL getters must be pure (no side effects)
      - NO setters - prefer immutable objects with copyWith
      - ALL classes with equality must override == and hashCode properly
      - NO Object.toString() overrides without @override annotation
      - ALL async functions must have comprehensive error handling
      - NO Future.value() or Future.error() without explicit error handling
      - ALL Duration values must be named constants
      - NO hard-coded colors - use theme or constants
      - ALL widget build methods must be under 50 lines
      - NO BuildContext extensions without proper documentation
      - ALL custom exceptions must extend appropriate base exceptions
      - NO rethrow without modification
      - ALL assert statements must have descriptive messages
      - NO late keyword without lazy initialization justification
      - ALL callback parameters must be nullable with ? or have default values
      - NO positional boolean parameters
      - ALL enums must have comprehensive documentation
      - NO extension methods without clear use cases
      - ALL typedef declarations must have documentation
      - NO part/part of directives without justification
  
  - path: "test/**/*.dart"
    instructions: |
      ULTRA-STRICT TEST REQUIREMENTS:
      - EVERY test MUST have clear arrange-act-assert structure with comments
      - EVERY edge case MUST be covered (null, empty, boundary values)
      - EVERY error scenario MUST be tested
      - Check for proper mock usage and cleanup in tearDown
      - Ensure tests are 100% isolated and don't depend on execution order
      - Verify async tests properly await ALL operations
      - Test naming MUST describe behavior: "should_expectedBehavior_when_condition"
      - EVERY public method MUST have at least 5 tests (happy path, 2 edge cases, 2 error scenarios)
      - EVERY private method MUST be tested through public APIs
      - EVERY branch MUST be tested
      - EVERY line MUST be covered
      - Code coverage MUST be 100% - NO exceptions
      - NO test.skip allowed
      - ALL mocks must be verified
      - ALL async operations must be tested for timeout scenarios
      - Test performance and memory leaks
      - Verify proper cleanup in tearDown/tearDownAll
      - Use proper matchers, not just equals
      - Test thread safety for concurrent code
      - Verify proper error messages in assertions
      
      ADDITIONAL TEST REQUIREMENTS:
      - ALL tests must use descriptive group() blocks
      - NO magic values in tests - use named constants
      - ALL DateTime values in tests must be fixed/mocked
      - NO actual network calls - use mocks or fakes
      - ALL file system operations must be mocked
      - NO shared state between tests
      - ALL setUp methods must be idempotent
      - NO test.only in committed code
      - ALL widget tests must use Keys for finding widgets
      - NO hardcoded delays (Future.delayed) - use FakeAsync or pumpAndSettle
      - ALL integration tests must be independent
      - NO flaky tests allowed
      - ALL test data must be in separate fixtures
      - NO inline JSON/XML - use separate files
      - ALL golden tests must have pixel-perfect matching
      - NO snapshot tests without proper validation
      - ALL performance tests must have clear benchmarks
      - NO tests that depend on external services
      - ALL tests must complete in under 5 seconds (unit tests)
      - NO tests that write to actual storage
      - ALL mocked responses must match actual API contracts
  
  - path: "lib/src/core/**/*.dart"
    instructions: |
      CORE ARCHITECTURE REQUIREMENTS (CRITICAL):
      - STRICT single responsibility principle - one class, one purpose
      - MANDATORY dependency injection - NO direct instantiation
      - ZERO hardcoded values - everything must be configurable
      - Proper use of abstract classes and interfaces for all contracts
      - Perfect separation of concerns - no cross-cutting
      - ALL core classes must be immutable
      - Use sealed classes for state management
      - Implement proper equals/hashCode for value objects
      - ALL core logic must be platform-agnostic
      - NO Flutter dependencies in core (except annotations)
      - Comprehensive error types with proper hierarchy
      - ALL public APIs must be documented with usage examples
      - Thread-safe implementations required
      - NO side effects in getters
      
      ADDITIONAL CORE REQUIREMENTS:
      - ALL interfaces must have at least 2 concrete implementations
      - NO God interfaces - keep interfaces small and focused
      - ALL value objects must be immutable with copyWith
      - NO inheritance deeper than 2 levels
      - ALL abstract classes must have documentation explaining when to extend vs implement
      - NO protected members - use private with public accessors
      - ALL core models must support serialization/deserialization
      - NO cyclic dependencies between modules
      - ALL domain logic must be testable without infrastructure
      - NO framework-specific code in domain layer
      - ALL use cases must follow Command/Query separation
      - NO business logic in DTOs/entities
      - ALL repositories must return domain models, not DTOs
      - NO use case depending on another use case directly
  
  - path: "lib/src/llm/**/*.dart"
    instructions: |
      LLM INTEGRATION CRITICAL REQUIREMENTS:
      - API key handling MUST be secure - NO hardcoding, use secure storage
      - MANDATORY rate limiting with exponential backoff
      - Streaming responses MUST handle all edge cases (disconnect, timeout, errors)
      - ALL timeout configurations must be configurable
      - Comprehensive error recovery with retry logic
      - ALL API calls must be cancellable
      - Proper request/response logging for debugging
      - Handle network failures gracefully
      - Implement circuit breaker pattern
      - ALL responses must be validated
      - Handle token limits properly
      - Implement proper request queuing
      - Monitor and log API usage metrics
      - Handle rate limit errors with proper backoff
      
      ADDITIONAL LLM REQUIREMENTS:
      - ALL API models must have schema validation
      - NO hardcoded prompts - use template system
      - ALL streaming must support pause/resume
      - NO blocking calls to LLM APIs
      - ALL responses must be sanitized before use
      - NO prompt injection vulnerabilities
      - ALL token counting must be accurate
      - NO exceeding context window limits
      - ALL multi-turn conversations must maintain context properly
      - NO storing API keys in memory longer than necessary
      - ALL API errors must be mapped to domain errors
      - NO exposing raw API responses to UI layer
      - ALL request builders must validate parameters
      - NO missing error codes in error handling
      - ALL retry logic must have maximum attempt limits
      - NO infinite retry loops
      - ALL cache invalidation must be explicit
      - NO stale data served from cache
  
  - path: "lib/src/voice/**/*.dart"
    instructions: |
      VOICE/AUDIO CRITICAL REQUIREMENTS:
      - ALL audio resources MUST be released in dispose/close
      - MANDATORY permission handling with proper user feedback
      - Audio buffer management must be memory-efficient
      - Comprehensive error handling for all audio failures
      - Handle microphone access errors gracefully
      - Proper audio session management
      - Handle background/foreground transitions
      - Implement proper audio focus handling
      - ALL audio streams must be properly closed
      - Handle audio interruptions (calls, notifications)
      - Proper sample rate and format handling
      - Memory leak prevention for audio buffers
      - Handle platform-specific audio issues
      
      ADDITIONAL VOICE REQUIREMENTS:
      - ALL audio formats must be documented
      - NO hardcoded sample rates
      - ALL audio processing must be done on background thread
      - NO blocking the UI thread with audio operations
      - ALL microphone permissions must be requested with rationale
      - NO accessing microphone without user consent
      - ALL audio recordings must have size limits
      - NO unbounded audio buffers
      - ALL audio quality settings must be configurable
      - NO assuming specific audio hardware capabilities
      - ALL audio errors must provide user-friendly messages
      - NO technical jargon in error messages to users
      - ALL voice activity detection must be configurable
      - NO false positive/negative triggers
  
  - path: "lib/src/memory/**/*.dart"
    instructions: |
      MEMORY/STORAGE CRITICAL REQUIREMENTS:
      - ZERO memory leaks - verify all resources are released
      - Proper data serialization with version migration
      - ALL operations MUST be thread-safe
      - Comprehensive cleanup mechanisms
      - Handle storage quota limits
      - Implement proper data encryption for sensitive data
      - ALL database operations must be transactional
      - Proper indexing for performance
      - Handle concurrent access properly
      - Implement data validation before storage
      - Proper error handling for storage failures
      - Implement data backup and recovery
      - Handle storage corruption gracefully
      
      ADDITIONAL MEMORY REQUIREMENTS:
      - ALL storage keys must be constants
      - NO magic strings for storage keys
      - ALL stored data must have expiration policies
      - NO indefinite data retention without cleanup
      - ALL cache implementations must have max size limits
      - NO unbounded caches
      - ALL encryption must use industry-standard algorithms
      - NO custom/weak encryption schemes
      - ALL sensitive data must be cleared on logout
      - NO persisting sensitive data after session end
      - ALL migrations must be backward compatible
      - NO breaking changes to storage schema without migration
      - ALL database queries must be optimized
      - NO N+1 query problems
      - ALL batch operations must be properly batched
      - NO iterative single operations
      - ALL data integrity must be validated on read
      - NO trusting stored data without validation

  - path: "lib/src/ui/**/*.dart"
    instructions: |
      UI/WIDGET CRITICAL REQUIREMENTS:
      - ALL widgets must be const where possible
      - NO rebuilding unchanged widgets
      - ALL keys must be provided for list items
      - NO missing keys in ListView/GridView children
      - ALL animations must be disposed properly
      - NO animation leaks
      - ALL controllers must be disposed
      - NO TextEditingController/ScrollController leaks
      - ALL InheritedWidgets must be immutable
      - NO mutable state in InheritedWidget
      - BuildContext NEVER used after async operations
      - ALL async operations in widgets must check mounted
      - NO setState during build phase
      - ALL side effects must be in initState/didChangeDependencies
      - NO business logic in build methods
      - Build methods must be pure functions
      - ALL loading states must be handled
      - NO missing loading indicators
      - ALL error states must be handled
      - NO unhandled error states in UI
      - ALL empty states must be handled
      - NO blank screens without explanation
      - ALL user inputs must be validated
      - NO trusting user input without validation
      - ALL forms must have proper validation
      - NO submitting invalid forms
      - ALL accessibility labels must be provided
      - NO missing Semantics widgets for screen readers
      - ALL colors must come from theme
      - NO hardcoded colors in widgets
      - ALL text styles must come from theme
      - NO hardcoded text styles
      - ALL spacing must use theme spacing
      - NO magic number spacing values
      - ALL responsive layouts for different screen sizes
      - NO fixed dimensions without constraints
      - ALL touch targets must be at least 48x48
      - NO tiny touch targets
      - ALL navigation must be properly managed
      - NO Navigator usage without named routes or GoRouter
      - ALL dialogs must be dismissible
      - NO modal dialogs without dismiss option
      - ALL bottom sheets must handle drag to dismiss
      - NO bottom sheets without drag indicators

  - path: "lib/src/models/**/*.dart"
    instructions: |
      DATA MODELS CRITICAL REQUIREMENTS:
      - ALL models must be immutable
      - NO mutable fields in data models
      - ALL models must implement proper equality
      - NO missing == and hashCode overrides
      - ALL models must support serialization
      - NO models without toJson/fromJson
      - ALL JSON parsing must handle null values
      - NO assuming non-null JSON values
      - ALL models must have copyWith methods
      - NO mutable state - use copyWith for changes
      - ALL model fields must be final
      - NO var or non-final fields
      - ALL optional fields must have proper null handling
      - NO required fields that should be optional
      - ALL model validation must be in factory constructors
      - NO invalid model instances allowed
      - ALL enums in models must have serialization
      - NO missing enum value handling in fromJson
      - ALL nested models must be properly typed
      - NO dynamic or Object types in models
      - ALL collections in models must be unmodifiable
      - NO mutable List/Map/Set in model fields
      - ALL models must have comprehensive toString
      - NO default Object.toString() implementations
      - ALL models must be documented
      - NO undocumented model fields
      - ALL date/time fields must be DateTime, not String
      - NO string-based date representations
      - ALL IDs must be strongly typed
      - NO string IDs without type wrappers

# Code Review Configuration
chat:
  auto_reply: true

# Review Focus Areas - ULTRA STRICT
tone_instructions: "Strictly enforce security, crash prevention, data safety, tests, docs, and best practices."

# Early access features
early_access: false

# Knowledge base settings
knowledge_base:
  opt_out: false
  learnings:
    scope: auto

# Custom instructions for all reviews
instructions: |
  CRITICAL FOCUS AREAS FOR FLUTTER/DART:
  
  1. NULL SAFETY (ZERO TOLERANCE):
     - Check for proper null handling everywhere
     - Ensure nullable types have null checks
  
  2. RESOURCE MANAGEMENT (MANDATORY):
     - All StreamControllers must be closed
     - All StreamSubscriptions must be cancelled
     - All TextEditingControllers must be disposed
     - All AnimationControllers must be disposed
     - All FocusNodes must be disposed
     - All ScrollControllers must be disposed
     - All custom Listenable objects must be disposed
  
  3. ASYNC/AWAIT SAFETY (CRITICAL):
     - BuildContext never used after await without mounted check
     - All Futures must be awaited or explicitly ignored with unawaited()
     - All async errors must be caught
     - No async gaps in lifecycle methods without checks
  
  4. WIDGET BEST PRACTICES:
     - Const constructors used wherever possible
     - Keys provided for list items and dynamic widgets
     - Build methods are pure (no side effects)
     - No business logic in build methods
     - Proper use of StatelessWidget vs StatefulWidget
  
  5. STATE MANAGEMENT:
     - Immutable state objects
     - Proper use of copyWith for updates
     - No mutable global state
     - Proper separation of UI and business logic
  
  6. TESTING REQUIREMENTS:
     - Every public method has tests
     - Edge cases are tested
     - Error scenarios are tested
     - Async operations are properly tested
     - Widget tests use proper finders and keys
  
  7. DOCUMENTATION:
     - All public APIs have dartdoc comments
     - Complex logic has inline comments
     - Non-obvious code has explanations
     - Examples provided for non-trivial APIs
  
  8. CODE QUALITY:
     - Methods under 30 lines
     - Classes under 200 lines
     - Cyclomatic complexity under 10
     - No code duplication
     - Proper naming conventions
     - Single responsibility per class/method
  
  9. ERROR HANDLING:
     - Comprehensive try-catch blocks
     - Specific exception types
     - Meaningful error messages
     - No empty catch blocks
     - Proper error propagation
  
  10. PERFORMANCE:
      - No N+1 query problems
      - Efficient collection operations
      - Proper use of const and final
      - No unnecessary rebuilds
      - Lazy loading where appropriate
  
  REVIEW PROCESS:
  1. First pass: Scan for critical issues (security, crashes, leaks)
  2. Second pass: Check test coverage and documentation
  3. Third pass: Review code quality and architecture
  4. Fourth pass: Check for improvements and best practices
  
  For EACH issue found:
  - Clearly state the problem
  - Explain why it's a problem
  - Provide a code example of the fix
  - Reference relevant documentation
  - Assign appropriate severity
  
  REQUEST CHANGES if ANY of these are true:
  - Critical or high severity issues present
  - Missing tests for new functionality
  - Missing documentation for public APIs
  - Resource leaks detected
  - Null safety violations
  - Potential crashes or bugs
  
  Only APPROVE when code meets ALL quality standards.